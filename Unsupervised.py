# -*- coding: utf-8 -*-
"""Ni Luh Made Dita Anjani_1301174676_Unsupervised.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pOPjMTPjR0i4xQK7JArJT6nlGnu86nuv

# Ni Luh Made Dita Anjani
1301174676

IFIK-41-01

# Data Exploration

Import Library
"""

import numpy as np 
import pandas as pd
import matplotlib as mpl
import random
mpl.rcParams['figure.dpi'] = 150

"""Load Data"""

from google.colab import files
uploaded = files.upload()

"""Membaca Data"""

import io
data = pd.read_csv(io.BytesIO(uploaded['used_cars.csv']))
data.head()

"""Cek info data"""

data.info()

"""# Preprocessing

Disini akan dicek permasing-masing atribut berapa jumlah missing value yang ada di setiap atribut, lalu jika ada kolom yang missing valuenya lebih dari 50% (yang mana tidak begitu efektif untuk akurasi) maka kolom tersebut didrop.
"""

data.isnull().sum()

miss = data.columns.where((data.isnull().sum() / len(data)) >=0.5).dropna()
data = data.drop(columns = miss)

"""Berikut data yang telah di drop karena missing value >= 50%"""

data.info()

"""Setelah dipertimbangkan, ada beberapa kolom yang sekiranya tidak diperlukan atau tidak memiliki pengaruh terhadap harga penjualan dan pembelian mobil. Kolom tersebut akan didrop."""

unused = ['Unnamed: 0', 'id', 'url', 'region_url', 'vin', 'drive', 'paint_color', 'image_url', 'description', 'state', 'lat', 'long']
data = data.drop(columns = unused)

"""cek data setelah beberapa column didrop."""

data.info()

"""# Handling Outlier

Disini akan dilakukan pengecekan weight pada boxplot di kolom price, year, dan odometer (kolom numerik)

Import Library
"""

# Commented out IPython magic to ensure Python compatibility.
import seaborn as sns
sns.set_style("whitegrid")
import matplotlib.pyplot as plt
# %matplotlib inline

"""Pengecekan Outlier pada atribut price, year, dan odometer."""

mpl.rcParams['figure.dpi'] = 250
plt.figure(figsize=(60, 60))
f, axes = plt.subplots(1, 3)
sns.boxplot(y=data["price"], ax=axes[0])
sns.boxplot(y=data["year"], ax=axes[1])
sns.boxplot(y=data["odometer"], ax=axes[2])
plt.subplots_adjust(wspace=1)

"""sebelum menghandle seluruh outliers, akan diecek terlebih dahulu per plotnya, terlihat dari boxplot bagian price, seperti banyak value 0 maka akan dicek berapa jumlah value 0 pada data price. Jika tidak terlalu banyak value 0, maka akan di drop."""

sum = 0
for i in range(len(data)):
  if (data['price'][i] == 0):
    sum = sum + 1
print(sum)

data.head()

"""Setelah pengecekan outlier menggunakan boxplot dan pengecekan pada data price, terdapat banyak value yang 'independen' di boxplot dan terdapat value dalam data price bernilai 0 maka dari itu akan dilakukan delete row untuk mengatasi outlier dari data atribut dan drop data value price yang bernilai 0."""

j = 0
data_index = []
for i in range(len(data)):
  if ((data['year'][i] < 2000) or ((data['price'][i] > 36200) or (data['price'][i] == 0)) or (data['odometer'][i] > 200000)):
    data = data.drop([i])
    j += 1
print("Jumlah data yang didrop : ", j)
data.info()

"""Berikut adalah hasil boxplot dari yang sudah dihilangkan outlier beserta price yang valuenya bernilai 0."""

mpl.rcParams['figure.dpi'] = 250
plt.figure(figsize=(60, 60))
f, axes = plt.subplots(1, 3)
sns.boxplot(y=data["price"], ax=axes[0])
sns.boxplot(y=data["year"], ax=axes[1])
sns.boxplot(y=data["odometer"], ax=axes[2])
plt.subplots_adjust(wspace=1)

"""# Handling Missing Value

Pada tahap ini akan ada pengecekan jumlah null yang ada pada setiap atribut
"""

data.isnull().sum()

"""Lalu akan dilakukan replace missing value dimana; untuk berbasis angka/nilai akan direplace dengan mean dari atribut tersebut, untuk kategorial akan direplace juga."""

kategorial = ['region','year', 'manufacturer', 'model', 'condition', 'cylinders', 'fuel', 'title_status', 'transmission', 'type']
numerik = ['price', 'odometer']
for i in numerik:
  data[i] = data[i].fillna(data[i].mean())
for j in kategorial:
  data[j] = data[j].fillna(data[j].mode().values[0])
data.isnull().sum()

data.head()

"""#Label Encoder

Disini akan dilakukan encode pada kolom-kolom yang memiliki atribut string/berupa objek, dan akan diubah menjadi bilangan numerik.
"""

from sklearn.preprocessing import LabelEncoder
category = kategorial
for i in category:
  num = LabelEncoder()
  data[i] = num.fit_transform(data[i].astype('str'))

data.head()

"""Data yang telah melalui preprocessing kemudian akan disimpan lalu akan diupload pada langkah berikutnya. (untuk meminimalisir error dan menghemat waktu upload download / sebagai checkpoint)"""

from google.colab import files
data.to_csv('fixedpreprocess.csv') 
files.download('fixedpreprocess.csv')

"""# Cek Persebaran Data & Scalling

Data yang telah didownload sebelumnya (fixedpreprocess.csv) akan diupload disini.
"""

from google.colab import files
uploaded_cluster = files.upload()

import io
data_preprocess = pd.read_csv(io.BytesIO(uploaded_cluster['fixedpreprocess.csv']))

"""Import library"""

from sklearn.preprocessing import MinMaxScaler
from sklearn.decomposition import PCA
import pandas

data_preprocess.head()

"""Akan dilakukan scalling disini menggunakan minmaxscaller dan PCA untuk penghitungan fit serta mereduce kolom menjadi 2."""

data_scaller = MinMaxScaler().fit_transform(data_preprocess)

pca = PCA(n_components=0.3, whiten=True)
X_pca = pca.fit_transform(data_scaller)
print('ori', data_scaller.shape[1])
print('reduced', X_pca.shape[1])
df = pd.DataFrame(X_pca)
df

"""Bisa dilihat ini adalah persebaran data sesuai dengan data yang telah dipreprocess dan melalui tahap scalling."""

import matplotlib.pyplot as plt
import numpy as np
from matplotlib import style
plt.figure(figsize=(30,28))
plt.scatter(df[0], df[1])
plt.xlabel('First principle component')
plt.ylabel('Second Principle component')

"""# Clustering

Mengubah X_pca yang tadinya object menjadi list array.
"""

X_pca = X_pca.tolist()
print(X_pca)

"""Mulai code clustering."""

import random
import pandas as pd
import numpy as np

#random centroid untuk 4 clusters
c1 = random.choice(X_pca)
c2 = random.choice(X_pca)
c3 = random.choice(X_pca)
c4 = random.choice(X_pca)

#perhitungan euclid distance (jarak) dengan centroid
max_iters = 50
for i in range(max_iters):
  print("ITERASI KE-", i)
  print("Centroid 1 awal : ",c1)
  print("Centroid 2 awal : ",c2)
  print("Centroid 3 awal : ",c3)
  print("Centroid 4 awal : ",c4)
  distance_centroid1 = []
  distance_centroid2 = []
  distance_centroid3 = []
  distance_centroid4 = []

  for i in range(len(X_pca)):
    count1 = abs((X_pca[i][0]-c1[0])+(X_pca[i][1]-c1[1]))
    distance_centroid1.append(count1)
    count2 = abs((X_pca[i][0]-c2[0])+(X_pca[i][1]-c2[1]))
    distance_centroid2.append(count2)
    count3 = abs((X_pca[i][0]-c3[0])+(X_pca[i][1]-c3[1]))
    distance_centroid3.append(count3)
    count4 = abs((X_pca[i][0]-c4[0])+(X_pca[i][1]-c4[1]))
    distance_centroid4.append(count4)
  # print("distance centroid 1 : ",distance_centroid1)
  # print("distance centroid 2 : ", distance_centroid2)

  #perbandingan centroid, dimana yg paling kecil akan masuk ke cluster tersebut
  idxcluster1 = []
  idxcluster2 = []
  idxcluster3 = []
  idxcluster4 = []
  cluster1 = []
  cluster1nol = []
  cluster1satu = []
  cluster2 = []
  cluster2nol = []
  cluster2satu = []
  cluster3 = []
  cluster3nol = []
  cluster3satu = []
  cluster4 = []
  cluster4nol = []
  cluster4satu = []
  array_cluster = []

  for i in range (len(X_pca)):
    if((distance_centroid1[i] < distance_centroid2[i]) and (distance_centroid1[i] < distance_centroid3[i]) and (distance_centroid1[i] < distance_centroid4[i])):
      idxcluster1.append(i)
      cluster1nol.append(X_pca[i][0])
      cluster1satu.append(X_pca[i][1])
      cluster1.append(X_pca[i])
      array_cluster.append(1)
    elif((distance_centroid2[i] < distance_centroid1[i]) and (distance_centroid2[i] < distance_centroid3[i]) and (distance_centroid2[i] < distance_centroid4[i])):
      idxcluster2.append(i)
      cluster2nol.append(X_pca[i][0])
      cluster2satu.append(X_pca[i][1])
      cluster2.append(X_pca[i])
      array_cluster.append(2)
    elif((distance_centroid3[i] < distance_centroid1[i]) and (distance_centroid3[i] < distance_centroid2[i]) and (distance_centroid3[i] < distance_centroid4[i])):
      idxcluster3.append(i)
      cluster3nol.append(X_pca[i][0])
      cluster3satu.append(X_pca[i][1])
      cluster3.append(X_pca[i])
      array_cluster.append(3)
    else:
      idxcluster4.append(i)
      cluster4nol.append(X_pca[i][0])
      cluster4satu.append(X_pca[i][1])
      cluster4.append(X_pca[i])
      array_cluster.append(4)

  # print("Cluster 1 : ",cluster1)
  # print("Cluster 2 : ",cluster2)
  # print("Cluster 3 : ",cluster3)
  # print("Cluster 4 : ",cluster4)

  #perhitungan tiap index, lalu di sum
  sumcluster1nol = np.sum(cluster1nol)
  sumcluster1satu = np.sum(cluster1satu)
  sumcluster2nol = np.sum(cluster2nol)
  sumcluster2satu = np.sum(cluster2satu)
  sumcluster3nol = np.sum(cluster3nol)
  sumcluster3satu = np.sum(cluster3satu)
  sumcluster4nol = np.sum(cluster4nol)
  sumcluster4satu = np.sum(cluster4satu)

  # hasil sum akan dihitung / jumlah len index per cluster
  c1 = ([sumcluster1nol/len(idxcluster1), sumcluster1satu/len(idxcluster1)])
  c2 = ([sumcluster2nol/len(idxcluster2), sumcluster2satu/len(idxcluster2)])
  c3 = ([sumcluster3nol/len(idxcluster3), sumcluster3satu/len(idxcluster3)])
  c4 = ([sumcluster4nol/len(idxcluster4), sumcluster4satu/len(idxcluster4)])

  #print centroid, akan auto update
  print("Centroid 1 updated : ", c1)
  print("Centroid 2 updated : ", c2)
  print("Centroid 3 updated : ", c3)
  print("Centroid 4 updated : ", c4)
  print("ARRAY CLUSTER : ",array_cluster)
  print("===========================================")

"""**plot hasil cluster & centroid berdasarkan warna.**

mengubah array to numpy agar plottingan lebih mudah dan tidak memakan waktu lama.
"""

import numpy as np
import matplotlib.pyplot as plt
cluster1 = np.array(cluster1)
cluster2 = np.array(cluster2)
cluster3 = np.array(cluster3)
cluster4 = np.array(cluster4)
c1 = np.array(c1)
c2 = np.array(c2)
c3 = np.array(c3)
c4 = np.array(c4)
print(cluster1)
print(cluster1[:,0])
print(c1[0])

import matplotlib.pyplot
plt.figure(figsize=(20,18))
plt.scatter(cluster1[:,0], cluster1[:,1], c='burlywood')
plt.scatter(cluster2[:,0], cluster2[:,1], c='peachpuff')
plt.scatter(cluster3[:,0], cluster3[:,1], c='lavender')
plt.scatter(cluster4[:,0], cluster4[:,1], c='thistle')
plt.scatter(c1[0], c1[1], c='black', marker='+')
plt.scatter(c2[0], c2[1], c='black', marker='+')
plt.scatter(c3[0], c3[1], c='black', marker='+')
plt.scatter(c4[0], c4[1], c='black', marker='+')

"""**Memasukkan Array Cluster ke dalam table data, untuk dieksekusi selanjutnya di dalam classification.**"""

print(array_cluster)
data.insert(12, "label", array_cluster)

data.head()

"""Download file untuk digunakan di classification."""

from google.colab import files
data.to_csv('clustering_result_data.csv') 
files.download('clustering_result_data.csv')
